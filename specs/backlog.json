[
    {
      "title": "Epic 1: Core Environment Engine",
      "body": "Goal: Provide a C++-based, Gym-style RL environment for NxN Tic-Tac-Toe.",
      "labels": ["epic"],
      "status": "completed",
      "completion_date": "2024-01-01",
      "notes": "Core environment fully implemented with board initialization, action transitions, and comprehensive terminal detection"
    },
    {
      "title": "US1.1: Initialize Board",
      "body": "As a developer, I want the environment to initialize an empty NxN board on `reset()` so that training always starts from a clean state.\n\n**Acceptance Criteria:**\n- `reset()` returns a `BoardState` with all cells = 0.\n- `BoardState.N` equals the configured board size.",
      "labels": ["user-story", "epic: Core Environment Engine"],
      "status": "completed",
      "completion_date": "2024-01-01",
      "notes": "Implemented in Environment::reset() method"
    },
    {
      "title": "US1.2: Apply Action & Transition",
      "body": "As a developer, I want `step(Action)` to update the board and return a `StepResult` so that agents can interact with the environment.\n\n**Acceptance Criteria:**\n- Applying a valid action sets the corresponding cell to the current player.\n- `StepResult.next_state` reflects the new board.\n- Invalid actions throw an exception or return a defined error code.",
      "labels": ["user-story", "epic: Core Environment Engine"],
      "status": "completed",
      "completion_date": "2024-01-01",
      "notes": "Implemented player alternation, action validation, bounds checking, and occupied cell detection with comprehensive tests"
    },
    {
      "title": "US1.3: Terminal Detection",
      "body": "As a developer, I want the engine to detect wins, losses, and draws in `step()` so that episodes terminate correctly.\n\n**Acceptance Criteria:**\n- Horizontal, vertical, diagonal N-in-a-row is detected as win/loss.\n- Full board with no winner returns `done = true`, `reward = 0`.",
      "labels": ["user-story", "epic: Core Environment Engine"],
      "status": "completed",
      "completion_date": "2024-01-01",
      "notes": "Implemented comprehensive terminal detection: horizontal, vertical, and diagonal wins for both players, plus draw detection when board is full with no winner"
    },
    {
      "title": "Epic 2: State & Action Representation",
      "body": "Goal: Expose board state and actions in formats usable by RL agents and LLMs.",
      "labels": ["epic"],
      "status": "not_started",
      "completion_date": null,
      "notes": "Basic BoardState struct exists, missing specialized representations"
    },
    {
      "title": "US2.1: Flattened State Vector",
      "body": "As a researcher, I want `get_flattened_state()` to return a 1D float vector so that I can feed it into neural networks.\n\n**Acceptance Criteria:**\n- Length = N×N.\n- Values in {–1, 0, +1} or normalized.",
      "labels": ["user-story", "epic: State & Action Representation"],
      "status": "not_started",
      "completion_date": null,
      "notes": "Method not yet implemented"
    },
    {
      "title": "US2.2: One-Hot Encoding Option",
      "body": "As an agent developer, I want an option to receive a one-hot encoded state tensor so that multi-channel models can be used.\n\n**Acceptance Criteria:**\n- Two channels: one for each player.\n- Shape = [2, N, N].",
      "labels": ["user-story", "epic: State & Action Representation"],
      "status": "not_started",
      "completion_date": null,
      "notes": "Method not yet implemented"
    },
    {
      "title": "US2.3: Action Masking",
      "body": "As a policy implementer, I want an action mask indicating legal moves so that the agent doesn't select invalid actions.\n\n**Acceptance Criteria:**\n- Returns a boolean vector length N×N with `true` on empty cells.",
      "labels": ["user-story", "epic: State & Action Representation"],
      "status": "not_started",
      "completion_date": null,
      "notes": "Method not yet implemented"
    },
    {
      "title": "Epic 3: Reward System & Custom Callbacks",
      "body": "Goal: Support default and user-provided reward logic.",
      "labels": ["epic"],
      "status": "partial",
      "completion_date": null,
      "notes": "RewardCallback interface implemented, missing default win/loss/draw rewards"
    },
    {
      "title": "US3.1: Default Win/Loss/Draw Rewards",
      "body": "As a user, I want default rewards (+1, –1, 0) so I can get basic signal out of the box.\n\n**Acceptance Criteria:**\n- Win → +1, Loss → –1, Draw → 0.",
      "labels": ["user-story", "epic: Reward System & Custom Callbacks"],
      "status": "not_started",
      "completion_date": null,
      "notes": "DefaultReward stub returns 0, need actual win/loss logic"
    },
    {
      "title": "US3.2: Pluggable RewardCallback Interface",
      "body": "As an advanced user, I want to inject my own `RewardCallback` functor so that I can define custom reward shaping.\n\n**Acceptance Criteria:**\n- Environment constructor accepts `std::shared_ptr<RewardCallback>`.\n- Callback invoked on each `step()`.",
      "labels": ["user-story", "epic: Reward System & Custom Callbacks"],
      "status": "completed",
      "completion_date": "2024-01-01",
      "notes": "RewardCallback abstract class and DefaultReward implemented"
    },
    {
      "title": "US3.3: Python-Backed Reward Hooks",
      "body": "As a Python user, I want to write reward functions in Python and bind via pybind11 so I can iterate faster on reward design.\n\n**Acceptance Criteria:**\n- Python callback can be registered and invoked each step.\n- No significant performance regression when using C++ callback.",
      "labels": ["user-story", "epic: Reward System & Custom Callbacks"],
      "status": "not_started",
      "completion_date": null,
      "notes": "pybind11 integration not yet implemented"
    },
    {
      "title": "Epic 4: RL Algorithm Integration",
      "body": "Goal: Provide templates and examples for PPO and GRPO in C++.",
      "labels": ["epic"],
      "status": "not_started",
      "completion_date": null,
      "notes": "No RL algorithm modules implemented yet"
    },
    {
      "title": "US4.1: PPO Module Skeleton",
      "body": "As a developer, I want a C++ PPO class template so I can plug in the environment state and action interfaces.\n\n**Acceptance Criteria:**\n- Implements policy/value networks (e.g., via Eigen or libtorch).\n- Exposes `collect_trajectories()` and `update()` methods.",
      "labels": ["user-story", "epic: RL Algorithm Integration"],
      "status": "not_started",
      "completion_date": null,
      "notes": "PPO module not yet implemented"
    },
    {
      "title": "US4.2: GRPO Module Skeleton",
      "body": "As a developer, I want a GRPO template with trust-region updates so I can compare algorithms side by side.\n\n**Acceptance Criteria:**\n- Implements conjugate-gradient trust-region solver.\n- Configurable TR radius.",
      "labels": ["user-story", "epic: RL Algorithm Integration"],
      "status": "not_started",
      "completion_date": null,
      "notes": "GRPO module not yet implemented"
    },
    {
      "title": "US4.3: Hyperparameter Configuration",
      "body": "As an engineer, I want to read alpha, gamma, batch size, etc., from YAML so I can tune experiments without recompiling.\n\n**Acceptance Criteria:**\n- YAML parser loads into a `Config` struct.\n- Both PPO/GRPO modules consume the same config.",
      "labels": ["user-story", "epic: RL Algorithm Integration"],
      "status": "not_started",
      "completion_date": null,
      "notes": "YAML configuration system not yet implemented"
    },
    {
      "title": "Epic 5: LLM Interaction",
      "body": "Goal: Let the environment or agent query an LLM for move suggestions or commentary.",
      "labels": ["epic"],
      "status": "not_started",
      "completion_date": null,
      "notes": "LLM integration not yet implemented"
    },
    {
      "title": "US5.1: HTTP LLM Connector",
      "body": "As a user, I want `LLMConnector` to send JSON payloads to a REST endpoint so I can use any hosted LLM.\n\n**Acceptance Criteria:**\n- Sends `{\"prompt\": \"...\", \"state\": {...}}` and parses a text response.",
      "labels": ["user-story", "epic: LLM Interaction"],
      "status": "not_started",
      "completion_date": null,
      "notes": "HTTP LLM connector not yet implemented"
    },
    {
      "title": "US5.2: gRPC LLM Connector (Optional)",
      "body": "As an enterprise integrator, I want gRPC support so I can leverage low-latency LLM services.\n\n**Acceptance Criteria:**\n- Supports proto-defined request/response.\n- Fallback to HTTP if gRPC fails.",
      "labels": ["user-story", "epic: LLM Interaction"],
      "status": "not_started",
      "completion_date": null,
      "notes": "gRPC LLM connector not yet implemented"
    },
    {
      "title": "US5.3: Move Suggestion Story",
      "body": "As a human-in-the-loop tester, I want to call `query_llm()` mid-game to get a suggested action so I can compare against policy.\n\n**Acceptance Criteria:**\n- Returns a valid `Action`.\n- LLM latency is logged but does not crash the environment.",
      "labels": ["user-story", "epic: LLM Interaction"],
      "status": "not_started",
      "completion_date": null,
      "notes": "LLM querying functionality not yet implemented"
    },
    {
      "title": "Epic 6: GPU Acceleration & Custom Kernels",
      "body": "Goal: Batch-process states/rewards on GPU for speed.",
      "labels": ["epic"],
      "status": "not_started",
      "completion_date": null,
      "notes": "GPU/CUDA integration not yet implemented"
    },
    {
      "title": "US6.1: KernelBatch Abstraction",
      "body": "As a performance engineer, I want a `KernelBatch` type to collect arrays of states or reward deltas so I can launch batched kernels.\n\n**Acceptance Criteria:**\n- Holds contiguous device memory pointers.\n- Can be reused across iterations.",
      "labels": ["user-story", "epic: GPU Acceleration & Custom Kernels"],
      "status": "not_started",
      "completion_date": null,
      "notes": "KernelBatch abstraction not yet implemented"
    },
    {
      "title": "US6.2: Example CUDA Kernel",
      "body": "As a GPU dev, I want a sample CUDA kernel that computes batched reward sums so I have a template for more complex ops.\n\n**Acceptance Criteria:**\n- Kernel compiles without errors.\n- Unit test verifies correctness vs. CPU version.",
      "labels": ["user-story", "epic: GPU Acceleration & Custom Kernels"],
      "status": "not_started",
      "completion_date": null,
      "notes": "CUDA kernel examples not yet implemented"
    },
    {
      "title": "US6.3: Dynamic Kernel Loading",
      "body": "As an advanced user, I want to load `.cu` files at runtime via NVRTC so I can experiment with kernels without recompiling the main binary.\n\n**Acceptance Criteria:**\n- Supports NVRTC compile and launch.\n- Errors are caught and surfaced gracefully.",
      "labels": ["user-story", "epic: GPU Acceleration & Custom Kernels"],
      "status": "not_started",
      "completion_date": null,
      "notes": "Dynamic kernel loading not yet implemented"
    },
    {
      "title": "Epic 7: Configuration & Serialization",
      "body": "Goal: Persist and exchange environment data and settings.",
      "labels": ["epic"],
      "status": "not_started",
      "completion_date": null,
      "notes": "Configuration and serialization not yet implemented"
    },
    {
      "title": "US7.1: JSON State & Episode Logging",
      "body": "As a researcher, I want to log every `StepResult` in JSONL so I can analyze runs offline.\n\n**Acceptance Criteria:**\n- Each line is a valid JSON object.\n- Schema includes timestamp, state, reward, done.",
      "labels": ["user-story", "epic: Configuration & Serialization"],
      "status": "not_started",
      "completion_date": null,
      "notes": "JSON logging not yet implemented"
    },
    {
      "title": "US7.2: YAML Config Loader",
      "body": "As a devops engineer, I want a single YAML file to configure env size, RL hyperparams, LLM endpoint, and CUDA settings.\n\n**Acceptance Criteria:**\n- Missing fields fallback to sensible defaults.\n- Validation errors during startup.",
      "labels": ["user-story", "epic: Configuration & Serialization"],
      "status": "not_started",
      "completion_date": null,
      "notes": "YAML configuration loader not yet implemented"
    },
    {
      "title": "Epic 8: Testing, CI & Quality",
      "body": "Goal: Ensure reliability through automated tests and CI.",
      "labels": ["epic"],
      "status": "partial",
      "completion_date": null,
      "notes": "Basic test and CI implemented, missing comprehensive test suite"
    },
    {
      "title": "US8.1: Unit Tests for Core Engine",
      "body": "As a maintainer, I want GoogleTest cases covering board reset, step transitions, and terminal conditions.\n\n**Acceptance Criteria:**\n- ≥90% coverage on core engine code.",
      "labels": ["user-story", "epic: Testing, CI & Quality"],
      "status": "partial",
      "completion_date": null,
      "notes": "Basic test exists, need GoogleTest framework and comprehensive coverage"
    },
    {
      "title": "US8.2: Integration Tests for PPO/GRPO",
      "body": "As a QA engineer, I want a smoke test that runs 100 episodes of PPO on 3×3 and reports a non-crash.\n\n**Acceptance Criteria:**\n- Test passes in under 30 seconds on CI.",
      "labels": ["user-story", "epic: Testing, CI & Quality"],
      "status": "not_started",
      "completion_date": null,
      "notes": "PPO/GRPO not implemented yet, can't test"
    },
    {
      "title": "US8.3: CI Pipeline",
      "body": "As a team, I want GitHub Actions to build, test, and lint on every PR so that regressions are caught early.\n\n**Acceptance Criteria:**\n- Workflow triggers on push/PR.\n- Fails fast on build or test errors.",
      "labels": ["user-story", "epic: Testing, CI & Quality"],
      "status": "partial",
      "completion_date": null,
      "notes": "GitHub Actions workflow created for starting US1.1 but needs to be updated at each new US"
    },
    {
      "title": "Epic 9: Documentation & Examples",
      "body": "Goal: Provide clear guides, tutorials, and demos.",
      "labels": ["epic"],
      "status": "not_started",
      "completion_date": null,
      "notes": "No documentation created yet beyond basic README"
    },
    {
      "title": "US9.1: README & Quickstart",
      "body": "As a new user, I want a README showing how to clone, build, run a basic loop so I can get started immediately.\n\n**Acceptance Criteria:**\n- Contains code snippets for CMake build and sample run.",
      "labels": ["user-story", "epic: Documentation & Examples"],
      "status": "not_started",
      "completion_date": null,
      "notes": "Basic README exists but needs quickstart guide"
    },
    {
      "title": "US9.2: Jupyter-Style Tutorial",
      "body": "As an educator, I want a notebook (via pybind11) that steps through environment usage and simple training so I can teach students.\n\n**Acceptance Criteria:**\n- Notebook runs end-to-end in <5 minutes.",
      "labels": ["user-story", "epic: Documentation & Examples"],
      "status": "not_started",
      "completion_date": null,
      "notes": "Jupyter tutorial not yet implemented"
    },
    {
      "title": "US9.3: API Reference",
      "body": "As an integrator, I want Doxygen or Sphinx-generated docs for all public classes and methods so I can integrate without reading source.\n\n**Acceptance Criteria:**\n- Published site link.\n- ≥80% of public methods documented.",
      "labels": ["user-story", "epic: Documentation & Examples"],
      "status": "not_started",
      "completion_date": null,
      "notes": "API documentation not yet implemented"
    }
  ]